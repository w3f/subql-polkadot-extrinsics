type Extrinsic @entity {
  id: ID!
  block_hash: String!
  block_nr: Int!
  timestamp: String!
  signer: String!
  index: Int!
  name: String!
  fields: [SilField]! @derivedFrom(field: "extrinsic")
  call_index: Int!
  docs: [String]!
  args: [FunctionArgument]! @derivedFrom(field: "extrinsic")
  call_data: String
}

type SilField @entity {
  id: ID!
  name: String
  type: Int!
  typeName: String
  docs: [String]!
  extrinsic: Extrinsic!
}

type FunctionArgument @entity {
  id: ID!
  name: String!
  type: String!
  typeName: String
  extrinsic: Extrinsic!
}

##### Reward and Staking #####
type SumReward @entity{
  id: ID! # AccountId
  accountReward: BigInt!
  accountSlash: BigInt!
  accountTotal: BigInt!
  rewards: [StakingReward] @derivedFrom(field: "account")
  slashs: [StakingSlash] @derivedFrom(field: "account")
}

# in early stage of kusama, some validators didn't need to bond to start staking
type NoBondRecordAccount @entity {
  id: ID! # AccountId
  firstRewardAt: Int!
}

type StakingReward @entity{
  id: ID! #blockHeight-eventIdx
  account: SumReward!
  balance: BigInt!
  date: Date!
}

type StakingSlash @entity{
  id: ID! #blockHeight-eventIdx
  account: SumReward!
  balance: BigInt!
  date: Date!
}

##### Transfer and Calls #####
type Account @entity {
  id: ID!
  transfers: [Transfer] @derivedFrom(field: "from")
}

type Transfer @entity {
  id: ID!
  amount: BigInt
  to: Account!
  from: Account!
}

type Call @entity {
  id: ID!
  module: String!
  method: String!
  parentCall: Call
  childCalls: [Call] @derivedFrom(field: "parentCall")
}
